# AGENT.md

## Project Overview

**e-Disaster Mobile (Android)** is an Android application built with **Kotlin** and **Jetpack Compose**.  
The app is part of a larger disaster management system that helps **officers** and **volunteers** manage and report real-time disaster situations.  
It connects to a **Laravel REST API backend** and uses **Firebase Cloud Messaging (FCM)** for push notifications.

---

## System Architecture Summary

**Frontend (Mobile):**

- Platform: Android (Kotlin + Jetpack Compose)
- Architecture: MVVM (Model - ViewModel - View)
- Networking: Retrofit
- State management: ViewModel + StateFlow
- Navigation: Jetpack Navigation Compose
- Notifications: Firebase Cloud Messaging (FCM)

**Backend (Web):**

- Laravel 12 with **Livewire + Volt** (for admin web panel)
- Built-in Laravel Authentication
- Pest for unit testing
- MySQL as the main database
- Provides REST API via `routes/api.php`
- Scheduled job to fetch real-time disaster data from [BMKG API](https://data.bmkg.go.id/gempabumi/) or manually input
- Sends push notifications via FCM when:
  - New disaster is detected (from BMKG or Manually)
  - New report is created
  - New disaster victim report is created
  - New disaster aid is received
  - Disaster status is updated
  - Volunteer is accepted or rejected by admin

---

## Key Entities and Relationships

**User Roles:**

- `admin` (web only)
- `officer`
- `volunteer`

**Main database tables:**

- `users`
- `disasters`
- `disaster_reports`
- `disaster_victims`
- `disaster_aids`
- `disaster_volunteers`
- `pictures`
- `notifications`

**Important relationship:**  
`disaster_volunteers` is a pivot table between `users` and `disasters`, representing which volunteers/officers are assigned to handle a specific disaster.

---

## Simplified Database Structure (ERD Overview)

**Enums**

```

users_type_enum: [admin, officer, volunteer]
users_status_enum: [registered, active, inactive]
picture_type_enum: [profile, disaster, report, victim, aid]
disaster_type_enum: [gempa bumi, tsunami, gunung meletus, banjir, kekeringan, angin topan, tanah longsor, bencana non alam, bencana sosial]
disaster_status_enum: [cancelled, ongoing, completed]
disaster_source_enum: [BMKG, manual]
disaster_victim_status_enum: [luka ringan, luka berat, meninggal, hilang]
disaster_aid_category_enum: [food, clothing, housing]
notification_type_enum: [verifikasi relawan, bencana baru, laporan bencana baru, laporan korban bencana baru, laporan bantuan bencana baru, status bencana berubah]

```

**Relationships**

```

notifications.user_id → users.id
disasters.reported_by → users.id
disaster_volunteers.user_id → users.id
disaster_volunteers.disaster_id → disasters.id
disaster_reports.reported_by → disaster_volunteers.id
disaster_victims.reported_by → disaster_volunteers.id
disaster_aids.reported_by → disaster_volunteers.id
pictures.foreign_id → related entity (users, disasters, reports, victims, aids)

```

---

## Project Folder Structure (Mobile)

```

app/
└── src/main/java/com/example/edisaster/
├── data/
│   ├── model/         # Data classes for API models & responses
│   ├── remote/        # Retrofit API service definitions
│   └── repository/    # Repository for data fetching and mapping
│
├── ui/
│   ├── screen/        # Compose screens (Login, Home, etc.)
│   ├── viewmodel/     # ViewModels for each screen
│   ├── components/    # Reusable UI components
│   ├── navigation/    # Navigation graph
│   └── theme/         # Color, typography, shapes
│
├── notification/      # FCM service and local notification handler
├── utils/             # Constants, helper functions
└── MainActivity.kt    # App entry point

````

---

## Theme Configuration

The app uses **Material 3 (M3)** design system with a custom color scheme based on the **BPBD brand color** `#EA5921` (orange).  
This color symbolizes alertness and energy, aligning with the disaster management theme.

**Theme rules:**

- **Primary color:** `#EA5921` (BPBD orange)
- **Secondary color:** auto-generated by Material 3 based on the primary seed
- **Background / Surface:** light (`#FFFFFF`) and dark (`#121212`)
- **Status colors:**
  - Green → success / completed
  - Yellow → warning / ongoing
  - Red → danger / error
- **Font:** Roboto / Inter / Poppins
- **Corner radius:** 12–16dp
- **Icons:** Material 3 Icons Extended
- **Spacing:** standard paddings (8dp, 16dp, 24dp)
- Supports both **light** and **dark** modes using `isSystemInDarkTheme()`

---

## Screen Flow Overview

The mobile app follows a **bottom navigation-based structure**, inspired by the Figma wireframes.  
All text in the app is in **Bahasa Indonesia**, with the primary color `#EA5921` (BPBD orange) used for actions.

**Bottom Navigation Tabs:**

1. **Beranda** — Dashboard showing ongoing and completed disasters.
2. **Daftar Bencana** — Full list of disasters with filters and search.
3. **Tambah (+)** — Floating button for adding new disasters.
4. **Riwayat** — Past handled disasters.
5. **Notifikasi** — Push notifications and system updates.

**Top Bar:**  
Displays logo (optional), title, and user avatar linking to Profile.

---

### Core Screen Groups

**0. Auth Screens**
- Login (email/password)
- Register (volunteer registration with pending approval)
- Profile (view/update details)

**1. Home (Dashboard)**
- Shows summary cards for active and completed disasters.

**2. Disaster Management**
- Daftar Bencana → searchable list
- Detail Bencana → shows description, location, and related tabs:
  - Perkembangan (Reports)
  - Korban (Victims)
  - Bantuan (Aid)
- Tambah / Edit Bencana → form for disaster CRUD
- Peta Bencana → map-based view (optional)
- Tambah / Update Perkembangan → disaster update forms

**3. Victim Management**
- Daftar Korban → searchable list
- Tambah / Update Laporan Korban → form for adding victims
- Detail Laporan Korban → info & edit/delete options

**4. Aid Management**
- Daftar Bantuan → list of provided/needed aids
- Tambah / Update Bantuan → form for aid management

**5. Notifications & History**
- Daftar Notifikasi → FCM notifications
- Riwayat → past handled disasters

---

## Data Access & Assignment Flow

### Volunteer & Officer Assignment Flow

#### Overview

Before a **volunteer** or **officer** can submit any disaster-related data (reports, victims, or aids),  
they must first be **assigned** to that disaster.  
This assignment is recorded in the **`disaster_volunteers`** table linking a `user` to a `disaster`.

There is **no separate "assigned" status column** —  
the existence of a record in `disaster_volunteers` means the user is assigned.

#### Database Reference

```sql
Table "disaster_volunteers" {
  "id" varchar(45) [pk, not null]
  "disaster_id" varchar(45)
  "user_id" varchar(45)
  "created_at" timestamp
  "updated_at" timestamp
}
````

Logic:

* ✅ Assigned → record exists for `(user_id, disaster_id)`
* ❌ Not assigned → no record found

---

#### Assignment Flow

1. **User opens Disaster Detail**

  * App checks via:

    ```
    GET /api/disaster-volunteers/check?disaster_id={id}
    ```

  * Backend responds:

    ```json
    { "assigned": true }
    ```

  * If assigned → show *Add Report / Add Victim / Add Aid* buttons

  * If not assigned → show *Join Disaster* button

2. **When user clicks “Join Disaster”**

  * API request:

    ```
    POST /api/disaster-volunteers
    {
      "disaster_id": "{uuid-of-disaster}"
    }
    ```

  * Backend logic:

    ```php
    if (!DisasterVolunteer::where('user_id', auth()->id())
                          ->where('disaster_id', $request->disaster_id)
                          ->exists()) {
        DisasterVolunteer::create([
            'id' => Str::uuid(),
            'user_id' => auth()->id(),
            'disaster_id' => $request->disaster_id,
        ]);
    }
    ```

  * Response:

    ```json
    { "message": "You are now assigned to this disaster." }
    ```

3. **Android UI Behavior**

  * If not assigned → “Join Disaster” button visible
  * Confirmation modal before joining:

    > “Are you sure you want to join this disaster response team?”
  * After joining:

    * Backend creates record in `disaster_volunteers`
    * App refreshes and displays new options:

      * Add Report
      * Add Victim
      * Add Aid

This ensures only assigned volunteers/officers can perform actions within a disaster context.

---

## API Integration

* All network requests use **Retrofit**
* `BASE_URL`: `https://edisaster.siunand.my.id/api/`
* All API responses: **JSON-based**
* FCM tokens stored in Laravel for targeted notifications

---

## Notification Behavior

| Type               | Triggered From       | Description                 |
| ------------------ | -------------------- | --------------------------- |
| `new_disaster`     | BMKG auto-fetch job  | New disaster detected       |
| `disaster_update`  | Admin/officer action | Status or details updated   |
| `new_report`       | Volunteer submission | New disaster report         |
| `new_victim_report`| Volunteer submission | New disaster victim report  |
| `new_aid_report`   | Volunteer submission | New disaster aid report     |
| `volunteer_status` | Admin approval       | Volunteer accepted/rejected |

Notifications are received via **FCM** and displayed through the local notification system.
Tapping a notification navigates the user to the relevant screen.

---

## Data Flow Example (MVVM + Retrofit)

```
1. User opens "Disaster List" screen
2. UI triggers → ViewModel.loadDisasters()
3. ViewModel calls → repository.getDisasters()
4. Repository sends → Retrofit request to /api/disasters
5. Backend returns → JSON list
6. Repository parses → returns List<Disaster>
7. ViewModel updates StateFlow → UI recomposes automatically
```

Example:

```kotlin
class DisasterViewModel(
    private val repository: DisasterRepository
) : ViewModel() {
    private val _disasters = MutableStateFlow<List<Disaster>>(emptyList())
    val disasters: StateFlow<List<Disaster>> = _disasters

    fun loadDisasters() {
        viewModelScope.launch {
            _disasters.value = repository.getDisasters()
        }
    }
}
```

---

## Development Notes

* Follow **MVVM separation**: `UI` ↔ `ViewModel` ↔ `Repository`
* Always update this file (`AGENT.md`) when architecture or API flow changes
* This file serves as a reference for **AI coding assistants** (Copilot, Cursor, etc.)
* Keep it **short, factual, and current**